package greatvaluekafka

import (
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"net/rpc"
	"strings"
	"sync"

	"github.com/google/uuid"
	"github.com/rs/zerolog/log"
)

type TopicCreateRequest struct {
	// the topic name
	Name string `json:"name"`
}

type TopicPublishRequest struct {
	Key     string `json:"key"`
	Message string `json:"message"`
}

type BrokerStatusReport struct {
	Active      bool
	BrokerIndex int
	// TODO: answer questions dynamically when we generate report.
	// - for topic i:
	//	 - for each partition j:
	// 		 - who is the leader?
}

type BrokerControlInterface struct {
	Activate   func() error
	Deactivate func() error
	Terminate  func() error
	GetStatus  func() (BrokerStatusReport, error)
}

// an instance of a kafka broker.
// each broker can have multiple topics.
type Broker struct {
	// the broker's participant index
	brokerIndex int

	httpServer     *http.Server
	shouldListen   bool
	controllerStub *rpc.Server

	// the broker's topics
	Topics sync.Map
}

// BrokerOpts are the options for creating a new broker
type BrokerOpts struct {
	BrokerIndex int

	// the address that pub/sub clients connect to
	BrokerAddr string

	// the address that listens to the controller
	ControlAddr string
}

// NewBroker creates a new broker
func NewBroker(bOpts *BrokerOpts) *Broker {
	b := &Broker{
		brokerIndex:    bOpts.BrokerIndex,
		Topics:         sync.Map{},
		controllerStub: rpc.NewServer(),
	}

	// Make sure this does not cause a deadlock
	brokerRPC := &BrokerRPC{
		Broker: b,
	}

	b.controllerStub.Register(brokerRPC)
	b.controllerStub.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)

	listener, err := net.Listen("tcp", bOpts.ControlAddr)
	if err != nil {
		log.Fatal().Err(err).Msgf("Failed to listen on %s", bOpts.ControlAddr)
	}
	go http.Serve(listener, nil)

	// create multiplexer
	mux := http.NewServeMux()

	// Register handlers
	mux.HandleFunc("/topics", b.handleTopicCreate)
	mux.HandleFunc("/topics/{name}/subscribe", b.handleTopicSubscribe)
	mux.HandleFunc("/subscribers/{id}/topics/{name}", b.handleTopicConsume)
	mux.HandleFunc("/topics/{name}/publish", b.handleTopicPublish)

	b.httpServer = &http.Server{
		Addr:    bOpts.BrokerAddr,
		Handler: b.activeMiddleware(mux),
	}

	return b
}

// Activate starts the broker server
func (b *Broker) Activate() error {
	log.Info().Msgf("Activating broker %v on %v", b.brokerIndex, b.httpServer.Addr)
	// start the http server where the broker listens for publisher/subscriber requests
	go func() {
		if err := b.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			fmt.Printf("Broker %v HTTP Server error: %v\n", b.brokerIndex, err)
		}
	}()

	b.shouldListen = true

	// TODO: activate the Topic, aka it's raft groups per partition
	return nil
}

func (b *Broker) Deactivate() error {
	log.Info().Msgf("Deactivating broker %v on %v", b.brokerIndex, b.httpServer.Addr)
	b.shouldListen = false

	// TODO: deactivate the Topic, aka it's raft groups per partition
	return nil
}

func (b *Broker) Terminate() error {
	b.shouldListen = false
	b.httpServer.Close()

	return nil
}

func (b *Broker) GetStatus() (BrokerStatusReport, error) {
	return BrokerStatusReport{
		Active:      b.shouldListen,
		BrokerIndex: b.brokerIndex,
	}, nil
}

// activeMiddleware serves as middleware for the http server; it is purely
// so that we dont have to actually shut down the server. we "pause" it.
func (b *Broker) activeMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !b.shouldListen {
			http.Error(w, "Service temporarily unavailable", http.StatusServiceUnavailable)
			return
		}
		next.ServeHTTP(w, r)
	})
}

// handleTopicCreate handles a topic creation request, if the topic exists already
// then it will soft fail (nothing happens)
func (b *Broker) handleTopicCreate(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	var req TopicCreateRequest

	err := json.NewDecoder(r.Body).Decode(&req)
	if err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	log.Printf("Received topic creation request: %v", req)

	// check if the topic already exists
	if _, ok := b.Topics.Load(req.Name); ok {
		w.WriteHeader(http.StatusOK)
		// TODO: return all relevant topic metadata
		w.Write([]byte(req.Name))
		return
	}

	// create the topic
	topic := NewTopic(req.Name, NUM_PARTITIONS)
	b.Topics.Store(req.Name, topic)
	w.WriteHeader(http.StatusCreated)
	w.Write([]byte(topic.Name))
}

// handleTopicSubscribe handles a topic subscription request
func (b *Broker) handleTopicSubscribe(w http.ResponseWriter, r *http.Request) {

	if r.Method != http.MethodPost {
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	// parse the topic name from the URL
	topicName := r.URL.Path[len("/topics/") : len(r.URL.Path)-len("/subscribe")]

	if topicName == "" {
		http.Error(w, "Invalid topic name", http.StatusBadRequest)
		return
	}

	log.Printf("Received topic subscription request: %v", topicName)

	// check if the topic exists
	topic, ok := b.Topics.Load(topicName)
	if !ok {
		http.Error(w, "Topic not found", http.StatusNotFound)
		return
	}

	// Typecase the topic to a *Topic
	topicPtr := topic.(*Topic)

	subscriberId := topicPtr.Subscribe(&Subscriber{
		ReadIndex: 0,
	})

	w.WriteHeader(http.StatusOK)
	w.Write([]byte(subscriberId.String()))
}

// handleTopicConsume handles a read request for a topic
func (b *Broker) handleTopicConsume(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	// parse the topic name and the sub id from the URL
	// the URL should be in the format /subscribers/{id}/topics/{name}

	tokens := strings.Split(r.URL.Path, "/")

	if len(tokens) != 5 {
		http.Error(w, "Invalid URL", http.StatusBadRequest)
		return
	}

	// Check if the subscriber id is a valid UUID
	subscriberId, err := uuid.Parse(tokens[2])

	if err != nil {
		http.Error(w, "Invalid subscriber id, must be a valid UUID", http.StatusBadRequest)
		return
	}

	topicName := tokens[4]
	if topicName == "" {
		http.Error(w, "Invalid topic name", http.StatusBadRequest)
		return
	}

	log.Printf("Received read request for topic %v and subscriber %v", topicName, subscriberId)

	// check if the topic exists
	topic, ok := b.Topics.Load(topicName)
	if !ok {
		http.Error(w, "Topic not found", http.StatusNotFound)
		return
	}

	// Typecase the topic to a *Topic
	topicPtr := topic.(*Topic)

	// check if the subscriber exists
	subscriber, exists := topicPtr.Subscribers.Load(subscriberId)
	if !exists {
		http.Error(w, "Subscriber not found", http.StatusNotFound)
		return
	}

	// Typecast the subscriber to a *Subscriber
	subscriberPtr := subscriber.(*Subscriber)

	// read the topic for the subscriber
	items := topicPtr.ReadBySub(subscriberPtr)

	// return the items as a json array
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(items)
}

// handleTopicPublish handles a publish request for a topic
func (b *Broker) handleTopicPublish(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	// parse the topic name from the URL
	topicName := r.URL.Path[len("/topics/") : len(r.URL.Path)-len("/publish")]
	if topicName == "" {
		http.Error(w, "Invalid topic name", http.StatusBadRequest)
		return
	}

	log.Printf("Received topic publish request: %v", topicName)

	// check if the topic exists
	topic, ok := b.Topics.Load(topicName)
	if !ok {
		http.Error(w, "Topic not found", http.StatusNotFound)
		return
	}

	// Typecase the topic to a *Topic
	topicPtr := topic.(*Topic)

	var req TopicPublishRequest
	err := json.NewDecoder(r.Body).Decode(&req)
	if err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	// TODO: Check if there is a problem with usign a goroutine here
	// Mainly doing this to avoid blocking the http request
	go topicPtr.PushToPartition([]byte(req.Message), req.Key)

}
